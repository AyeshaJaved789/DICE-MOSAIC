# -*- coding: utf-8 -*-
"""dice_mosaic.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KkdK00FN5KSMyQo-yhGvaVxRmkVm1Yky
"""

import streamlit as st
from PIL import Image
import numpy as np
import io
import os

# Page configuration
st.set_page_config(page_title="üé≤ Dice Mosaic Generator", layout="centered")

# Title and instructions
st.title("üé≤ Dice Mosaic Art Generator")
st.markdown("""
Upload any image, choose your dice size and style, and convert the image into a mosaic made entirely of dice faces!
""")

# Sidebar settings
st.sidebar.title("‚öôÔ∏è Settings")
dice_width = st.sidebar.slider("Dice Width (px)", min_value=5, max_value=100, value=20)
dice_height = st.sidebar.slider("Dice Height (px)", min_value=5, max_value=100, value=20)
dice_size = (dice_width, dice_height)

# Mosaic color mode
color_mode = st.sidebar.radio("üé® Mosaic Style", ["Color", "Black & White"])

# Upload image
uploaded_file = st.file_uploader("üì§ Upload your image (JPG or PNG)", type=["jpg", "jpeg", "png"])

# Load dice images
@st.cache_data
def load_dice_images(size):
    dice_imgs = {}
    for i in range(1, 7):
        try:
            dice_img = Image.open(f"dice {i}.png").convert("RGBA").resize(size)
            dice_imgs[i] = dice_img
        except Exception as e:
            st.error(f"Couldn't load 'dice {i}.png': {e}")
    return dice_imgs

# Map brightness to dice face
def intensity_to_dice_face(intensity):
    face = 6 - int(np.floor((intensity / 255) * 6))
    return max(1, min(face, 6))

# Generate dice mosaic
def create_dice_mosaic(image, dice_size, dice_images, color_mode):
    image = image.convert("RGB")
    width, height = image.size

    # Pad image
    pad_w = (dice_size[0] - width % dice_size[0]) % dice_size[0]
    pad_h = (dice_size[1] - height % dice_size[1]) % dice_size[1]
    new_w, new_h = width + pad_w, height + pad_h

    padded_img = Image.new('RGB', (new_w, new_h), (255, 255, 255))
    padded_img.paste(image, (0, 0))

    img_array = np.array(padded_img)
    mosaic_img = Image.new('RGB', (new_w, new_h))

    for y in range(0, new_h, dice_size[1]):
        for x in range(0, new_w, dice_size[0]):
            block = img_array[y:y + dice_size[1], x:x + dice_size[0]]
            avg_color = np.mean(block, axis=(0, 1))
            brightness = np.dot(avg_color, [0.299, 0.587, 0.114])
            face = intensity_to_dice_face(brightness)

            dice_img = dice_images.get(face)
            if dice_img:
                if color_mode == "Color":
                    # Tinting dice with average color
                    tinted = Image.new('RGB', dice_size, tuple(avg_color.astype(int)))
                    mask = dice_img.convert('L')
                    tinted.paste(dice_img, (0, 0), mask)
                    mosaic_img.paste(tinted, (x, y))
                else:
                    # Use dice image as-is for B&W
                    mosaic_img.paste(dice_img.convert("RGB"), (x, y))

    return mosaic_img

# Run the app if image is uploaded
if uploaded_file is not None:
    try:
        original_img = Image.open(uploaded_file)
        st.subheader("üì∑ Original Image")
        st.image(original_img, use_column_width=True)

        dice_images = load_dice_images(dice_size)

        st.subheader("üé® Dice Mosaic")
        mosaic = create_dice_mosaic(original_img, dice_size, dice_images, color_mode)
        st.image(mosaic, use_column_width=True)

        # Download button
        buf = io.BytesIO()
        mosaic.save(buf, format="PNG")
        byte_im = buf.getvalue()

        st.download_button(
            "‚¨á Download Your Mosaic",
            data=byte_im,
            file_name="dice_mosaic.png",
            mime="image/png"
        )

    except Exception as e:
        st.error(f"‚ùå Error processing the image: {e}")
else:
    st.info("üëà Upload an image from the uploader above to begin.")
